/*
 * pipeline_listener.cpp
 *
 * Class implementation of a Royale listener object to execute
 * the object avoidance pipeline.
 */

#include "pipeline_listener.h"
#include "common.h"

#include <memory>
#include <mutex>
#include <sys/time.h>
#include <syslog.h>


MyListener::MyListener(const bool quiet, const std::string pointcloud_dir, const std::string grayscale_dir,  std::vector<float>* vec_x, std::vector<float>* vec_y, std::vector<float>* vec_z,
                      std::vector<uint16_t>* vec_gray) :
    m_quiet(quiet), m_pointcloud_dir(pointcloud_dir), m_grayscale_dir(grayscale_dir), m_last_frame_timestamp_long(0), m_royale_data_timeStamp(0)
{
  m_point_cloud_x = vec_x;
  m_point_cloud_y = vec_y;
  m_point_cloud_z = vec_z;
  m_gray_image = vec_gray;
}


MyListener::~MyListener()
{
}

/**
 * SaveDensePointcloud
 *
 * Streams the pointcloud data to a local file in a .ply format
 * For an explanation of the PLY file format please have a look at
 * https://en.wikipedia.org/wiki/PLY_(file_format)
*/
void MyListener::SaveDensePointcloud(const std::string &filename, const std::string &filename_gray, const royale::DepthData *data) {
  std::ofstream outputFile;
  std::stringstream stringStream;

  std::ofstream outputFile_gray;
  std::stringstream stringStream_gray;
  uint16_t gray_val;
  uint16_t mask = 255;
  uint8_t byte_low, byte_high;

  outputFile_gray.open (filename_gray, std::ofstream::out);
  if (outputFile_gray.fail()) {
    std::cerr << "Outputfile " << filename_gray << " could not be opened!" << std::endl;
    return;
  }

  outputFile.open (filename, std::ofstream::out);
  if (outputFile.fail()) {
    std::cerr << "Outputfile " << filename << " could not be opened!" << std::endl;
    return;
  } else {
    // if the file was opened successfully write the PLY header
    stringStream << "ply" << std::endl;
    stringStream << "format ascii 1.0" << std::endl;
    stringStream << "comment Generated by tof-daemon" << std::endl;
    stringStream << "element vertex " << data->points.size() << std::endl;
    stringStream << "property float x" << std::endl;
    stringStream << "property float y" << std::endl;
    stringStream << "property float z" << std::endl;
    stringStream << "element face 0" << std::endl;
    stringStream << "property list uchar int vertex_index" << std::endl;
    stringStream << "end_header" << std::endl;

    // output XYZ coordinates into one line
    for (size_t i = 0; i < data->points.size(); ++i) {
        stringStream << data->points[i].x << " " << data->points[i].y << " " << data->points[i].z << std::endl;

        gray_val = data->points[i].grayValue;
        byte_low = static_cast<uint8_t>((gray_val) & mask);
        byte_high = static_cast<uint8_t>((gray_val >> 8) & mask);

        stringStream_gray << byte_low << " " << byte_high << std::endl;
        // reconstruct like this: gray_val = byte_low | (byte_high << 8);
    }
    // output stringstream to file and close it
    outputFile << stringStream.str();
    outputFile.close();

    outputFile_gray << stringStream_gray.str();
    outputFile_gray.close();
  }
}


// Helper to output time deltas for time benchmaking
void MyListener::DisplayTimeDeltaMS(const struct timeval &startTime, const struct timeval &endTime, const char *comment) {
  const double TIME_DELTA = static_cast<double>(endTime.tv_sec - startTime.tv_sec) * 1000. + static_cast<double>(endTime.tv_usec - startTime.tv_usec) / 1000.;
  if(!m_quiet) {
    syslog(LOG_NOTICE, "TOFDaemon %s: time delta took %g milliseconds\n", comment, TIME_DELTA);
  }
}


/**
 * onNewData
 *
 * Callback to execute the object avoidance pipeline.
 */
void MyListener::onNewData(const royale::DepthData *data) {
  static int counter = 0;
  counter++;

  struct timespec start, stop;
  double accum;

  if( clock_gettime( CLOCK_BOOTTIME, &start) == -1 ) {
    syslog(LOG_ERR, "Error: Failed to get clock start time\n");
  }
  // struct timeval startTime;
  // gettimeofday(&startTime, NULL);

  m_royale_data_timeStamp = data->timeStamp.count();
  int64_t time_diff =(m_royale_data_timeStamp - m_last_frame_timestamp_long) / 1000L;
  // syslog(LOG_NOTICE, "timestamp %ld  :::  previous %ld\n", m_royale_data_timeStamp, m_last_frame_timestamp_long);
  syslog(LOG_NOTICE, "TIME DIFF TOF ::: %ld\n", time_diff);
  m_last_frame_timestamp_long = m_royale_data_timeStamp;

  /*
  if(m_last_frame_timestamp_long > 0) {
    if(m_last_frame_timestamp_long < m_royale_data_timeStamp) {
      m_last_frame_timestamp_long = m_royale_data_timeStamp;
    } else {
      syslog(LOG_NOTICE, "Skipping Frame : Timestamp Diff = 0\n");
      return;
    }
  }else{
      m_last_frame_timestamp_long = m_royale_data_timeStamp;
  }
  */

  /* long long cur_timestamp_long = (long long) static_cast<long long>(startTime.tv_sec) * 1000L + static_cast<long long>(startTime.tv_usec) / 1000L;
  if(m_last_frame_timestamp_long > 0) {
      if( (cur_timestamp_long - m_last_frame_timestamp_long) < 120 ) {
          std::string timestamp_diff = std::to_string(cur_timestamp_long - m_last_frame_timestamp_long);
          syslog(LOG_NOTICE, "Skipping Frame : Timestamp Diff = %s\n", timestamp_diff.c_str());
          return;
      }else{
          m_last_frame_timestamp_long = cur_timestamp_long;
      }
  }else{
      m_last_frame_timestamp_long = cur_timestamp_long;
      m_royale_data_timeStamp = data->timeStamp;
  }*/

  // m_depth_points =  data->points;
  {
    std::unique_lock<std::mutex> lock (g_ptcloud_mutex);
    // m_royale_data_timeStamp = data->timeStamp;
    for (size_t index = 0u; index < m_point_cloud_x->size(); ++index) {
      (*m_point_cloud_x)[index] = data->points[index].x;
      (*m_point_cloud_y)[index] = data->points[index].y;
      (*m_point_cloud_z)[index] = data->points[index].z;
      (*m_gray_image)[index] = data->points[index].grayValue;
    }
  }

  //struct timeval createPCLTime;
  //gettimeofday(&createPCLTime, NULL);
  //DisplayTimeDeltaMS(startTime, createPCLTime, "CreatePointCloud");

  /*
  // Test if m_pointcloud_dir is not empty
  if ((counter < 11) && !m_pointcloud_dir.empty()) {
    // If a directory is defined then save pointcloud
    //struct timeval tp;
    //gettimeofday(&tp, NULL);
    // Must cast to long long to avoid overflows
    // long long msec_long = (long long) startTime.tv_sec * 1000L + startTime.tv_usec / 1000;
    // std::string timestamp = std::to_string(msec_long);
    std::string timestamp = std::to_string(m_royale_data_timeStamp);
    std::string filename = "densePointCloud_" + timestamp + ".ply";
    filename = m_pointcloud_dir + filename;
    // std::string lclpth = "/home/root/tof-data-repo/";
    // filename = lclpth + filename;
    std::string filename_gray = "grayscale_" + timestamp + ".raw16";
    filename_gray = m_grayscale_dir + filename_gray;
    // filename_gray = lclpth + filename_gray;

    SaveDensePointcloud(filename, filename_gray, data);
  }
  */

  if( clock_gettime( CLOCK_BOOTTIME, &stop) == -1 ) {
    syslog(LOG_ERR, "Error: Failed to get clock stop time\n");
  }

  accum = static_cast<double>( stop.tv_sec - start.tv_sec ) * 1000.0 + static_cast<double>( stop.tv_nsec - start.tv_nsec ) / 1000000.0;
  syslog(LOG_NOTICE, "TIME DIFF SYSTEM *:::* %lf\n", accum);
  // struct timeval finalTime;
  // gettimeofday(&finalTime, NULL);
  // DisplayTimeDeltaMS(startTime, finalTime, "Total Elapsed Time: ");

  g_newDataAvailable = true;
  g_ptcloud_cv.notify_all();
}
