/****************************************************************************\
 * Copyright (C) 2015 pmdtechnologies ag
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 \****************************************************************************/

#include "PLYWriter.hpp"

#include <cstdint>
#include <fstream>
#include <sstream>

using namespace royale;

void PLYWriter::writePLY (const std::string &filename, const royale::DepthData *data)
{
    if (!data)
    {
        return;
    }
    std::ofstream outputFile;
    std::stringstream stringStream;

    outputFile.open (filename, std::ofstream::out);

    if (outputFile.fail())
    {

    }
    else
    {
        stringStream << "ply" << std::endl;
        stringStream << "format ascii 1.0" << std::endl;
        stringStream << "comment Generated by royaleviewer " << ROYALE_VERSION_MAJOR << "." << ROYALE_VERSION_MINOR << "." << ROYALE_VERSION_PATCH << ROYALE_VERSION_BUILD << std::endl;
        stringStream << "element vertex " << data->points.size() << std::endl;
        stringStream << "property float x" << std::endl;
        stringStream << "property float y" << std::endl;
        stringStream << "property float z" << std::endl;
        stringStream << "property uchar red" << std::endl;
        stringStream << "property uchar green" << std::endl;
        stringStream << "property uchar blue" << std::endl;
        stringStream << "element face 0" << std::endl;
        stringStream << "property list uchar int vertex_index" << std::endl;
        stringStream << "end_header" << std::endl;

        uint16_t minAmp{ 65535 };
        uint16_t maxAmp{ 0 };

        for (size_t i = 0; i < data->points.size(); ++i)
        {
            if (data->points.at (i).depthConfidence > 0)
            {
                if (data->points.at (i).grayValue < minAmp)
                {
                    minAmp = data->points.at (i).grayValue;
                }
                else if (data->points.at (i).grayValue > maxAmp)
                {
                    maxAmp = data->points.at (i).grayValue;
                }
            }
        }

        auto range = static_cast<float> (maxAmp - minAmp);
        if (range == 0.0f)
        {
            range = 1.0f;
        }
        for (size_t i = 0; i < data->points.size(); ++i)
        {
            uint32_t pixelColor = 0u;
            if (data->points.at (i).depthConfidence > 0)
            {
                pixelColor = static_cast<uint32_t> ( (static_cast<float> (data->points.at (i).grayValue - minAmp) / range) * 255.0f);
            }
            stringStream << data->points.at (i).x << " " << data->points.at (i).y << " " << data->points.at (i).z << " ";
            stringStream << pixelColor << " " << pixelColor << " " << pixelColor << std::endl;
        }

        outputFile << stringStream.str();

        outputFile.close();
    }
}

