/****************************************************************************\
 * Copyright (C) 2019 pmdtechnologies ag
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 \****************************************************************************/

#include <importExportHelperLib/plyHelper.hpp>

#include <sstream>

using namespace royale;
using namespace royale::importExportHelperLib;

CameraStatus royale::importExportHelperLib::encodePLY (const royale::DepthData *depthData, std::ostream &outPLY)
{
    outPLY <<
           "ply\n"
           "format ascii 1.0\n"
           "comment Generated by royaleviewer " << ROYALE_VERSION_MAJOR << "." << ROYALE_VERSION_MINOR << "." << ROYALE_VERSION_PATCH << "." << ROYALE_VERSION_BUILD << "\n"
           "element vertex " << depthData->points.size() << "\n"
           "property float x\n"
           "property float y\n"
           "property float z\n"
           "property float amplitude\n"
           "property uchar red\n"
           "property uchar green\n"
           "property uchar blue\n"
           "element face 0\n"
           "property list uchar int vertex_index\n"
           "end_header\n";

    uint16_t minAmp{ 65535 };
    uint16_t maxAmp{ 0 };

    for (const auto &point : depthData->points)
    {
        if (point.depthConfidence > 0)
        {
            if (point.grayValue < minAmp)
            {
                minAmp = point.grayValue;
            }
            else if (point.grayValue > maxAmp)
            {
                maxAmp = point.grayValue;
            }
        }
    }

    auto range = static_cast<float> (maxAmp - minAmp);
    if (range == 0.0f)
    {
        range = 1.0f;
    }

    for (const auto &point : depthData->points)
    {
        uint32_t pixelColor{ 0 };
        if (point.depthConfidence > 0)
        {
            pixelColor = static_cast<uint32_t> ( (static_cast<float> (point.grayValue - minAmp) / range) * 255.0f);
        }
        outPLY
                << point.x << ' '
                << point.y << ' '
                << point.z << ' '
                << static_cast<float> (point.grayValue) << ' '
                << pixelColor << ' '
                << pixelColor << ' '
                << pixelColor << '\n';
    }

    return CameraStatus::SUCCESS;
}

CameraStatus royale::importExportHelperLib::encodePLY (const royale::DepthData *depthData, std::string &outPLY)
{
    std::stringstream outBuffer{};
    auto returnCode = encodePLY (depthData, outBuffer);

    if (CameraStatus::SUCCESS == returnCode)
    {
        outPLY = outBuffer.str();
    }

    return returnCode;
}
