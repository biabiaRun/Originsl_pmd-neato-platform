#!/usr/bin/python3

# Copyright (C) 2018 Infineon Technologies
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
# PARTICULAR PURPOSE.

"""Command-line interface to convert settings, calibration and register maps to
the Zwetschge binary image format.

Example usage:

    python3 zwetschge_tool.py --device example/ExampleDevice.py --calibration dummycalib.jgf --serial 0123-4567-8901-2345 --suffix ModuleSuffix --outfile example.zwetschge

    python3 zwetschge_tool.py --lena --device example/ExampleDevice.py --outfile example.lena

Inputs:

    The currently supported import format is for each device to be provided as
    as a Python package with a main module whose getZwetschgeDeviceData() method
    returns an instance of ZwetschgeDataTypes.DeviceData.

    A device normally has multiple use cases, this format allows per-use-case
    register settings to be provided in separate files, with the
    getZwetschgeDeviceData() function using Python's module support to combine
    them.

    The ExampleDevice.py file and its directory show how this works in practice.

Usage of the binary data:

    The M2453 imagers include hardware support for accessing an SPI-connected
    storage device. They can automatically load firmware from the storage, and
    can load register maps directly from the storage.  A new data layout,
    Zwetschge, stores the calibration and information about supported use cases,
    which Royale needs to read. It also contains the register settings for use
    cases, which can either be read directly by the imager, or read in to Royale
    and then written back to the imager.

    The Zwetschge format can also be stored in other locations, but then it
    obviously could not be read directly by the imager.

Migration from the py2lena tool:

    The py2lena tool could take a directory of per-use-case register settings,
    and generate a set of files that needed further hand-editing to add the use
    case names before combining then to make a .lena file.

    For the Zwetschge Tool, all the information that would be added in py2lena's
    hand-editing step is in the main module (the ExampleDevice.py file).  With
    this additional file, the rest of the input files for py2lena can be used
    as-is.

    The Zwetschge Tool can also be used to generate Lena files, without needing
    the hand-editing step.  Lena files generated by this tool do not include any
    comments that were in the original .py files, but the original .py files can
    now be treated as editable source and the .lena automatically generated;
    this change in workflow is an important step in migration to Zwetschge.

Including calibration data:

    Zwetschge can include calibration data, assuming this file is being created
    for a specific module and not as a generic file for the entire device
    family. Use the --calibration option for this.

Including calibration data:

    To set the module serial for the specific module use the --serial option.
"""

import argparse
import logging
import zwetschge_tool
from zwetschge_tool.lena.writer import LenaWriter
from zwetschge_tool.zwetschge.writer import ZwetschgeWriter, ZwetschgeWriterWithoutReserved
from zwetschge_tool.util.import_device_data import importDeviceData


def main ():
    parser = argparse.ArgumentParser(usage = __doc__)
    parser.add_argument ("--calibration", help="Filename from which to load calibration data")
    parser.add_argument ("--device", help="Python module to execute to get a complete device description")
    formatGroup = parser.add_mutually_exclusive_group()
    formatGroup.add_argument ("--lena", action="store_true", help="OUTPUTFORMAT: Write Lena format instead of Zwetschge format")
    parser.add_argument ("--no-validate", dest="validate", action="store_false", help="Skip sanity-checking the data")
    parser.add_argument ("--outfile", help="Zwetschge file to write")
    parser.add_argument ("--verbose", action="store_true", help="Print details about the device")
    parser.add_argument ("--serial", help="Module serial of the device")
    parser.add_argument ("--suffix", help="Module suffix of the device")
    options = parser.parse_args()

    logger = logging.getLogger('pmdpy')

    if options.verbose:
        ch = logging.StreamHandler()
        logger.addHandler(ch)
        logger.setLevel(logging.DEBUG)
        
    logger.info('Zwetschge Tool version is: {}'.format(zwetschge_tool.__version__))

    # The device data is currently stored directly as Python, but this section could be changed to
    # load a parser for a non-executable data format.
    if options.device:
        device = importDeviceData (options.device)
    else:
        raise Exception ("This requires a --device argument")

    logger.info (device)

    calibration = None
    if options.calibration:
        with open (options.calibration, "rb") as infile:
            calibration = infile.read()

    moduleSerial = None
    if options.serial:
        moduleSerial = options.serial

    moduleSuffix = None
    if options.suffix:
        moduleSuffix = options.suffix
        
    if options.validate:
        from zwetschge_tool.zwetschge.validator import Validator
        validator = Validator()
        validator.check (device, calibration)

    if options.lena:
        writer = LenaWriter (device, calibration)
    else:
        writer = ZwetschgeWriterWithoutReserved (device, calibration, moduleSerial, moduleSuffix)
    content = writer.pack()

    # If no outfile option is given, just warn that the only output was the stdout debugging
    # in the exportAsZwetschge function.
    if not options.outfile:
        print ('No output file given with the --outfile option')

    if options.outfile:
        outFile = open (options.outfile, "wb")
        outFile.write (content)

if __name__ == "__main__":
    main()
